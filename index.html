// --- Heart particle system (ใหม่) ---
const canvas = document.getElementById('particles');
const ctx = canvas.getContext('2d');

let heartsOn = true;        // on/off
let hearts = [];

function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.clientWidth || canvas.offsetWidth;
  const h = canvas.clientHeight || canvas.offsetHeight;
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Try to estimate a model radius in pixels.
// Order of preference: manual override -> model-viewer bounding box -> fallback fraction of canvas
function getModelRadiusPx(){
  const manual = viewerWrap.getAttribute('data-model-radius');
  if(manual) return Number(manual);

  try{
    if(typeof mv.getBoundingBox === 'function'){
      const bbox = mv.getBoundingBox();
      if(bbox && bbox.min && bbox.max){
        const size = Math.max(
          Math.abs(bbox.max.x - bbox.min.x),
          Math.abs(bbox.max.y - bbox.min.y),
          Math.abs(bbox.max.z - bbox.min.z)
        );
        // heuristic multiplier to convert 3D model size -> approximately pixel radius
        return Math.max(50, size * 220);
      }
    }
  }catch(e){
    // ignore; fallback below
  }

  return Math.max(80, canvas.clientWidth * 0.18);
}

// Heart drawing helpers (normalized heart path)
function drawHeartPath(ctx){
  ctx.beginPath();
  // normalized shape centered around (0,0)
  ctx.moveTo(0, -7);
  ctx.bezierCurveTo(0, -15, -12, -15, -12, -7);
  ctx.bezierCurveTo(-12, 0, 0, 10, 0, 16);
  ctx.bezierCurveTo(0, 10, 12, 0, 12, -7);
  ctx.bezierCurveTo(12, -15, 0, -15, 0, -7);
  ctx.closePath();
}

class Heart {
  constructor(x, y, size, vy, vx, life, rot, rotSpeed, color){
    this.x = x;
    this.y = y;
    this.size = size;        // px
    this.vy = vy;            // px/sec (upward)
    this.vx = vx;            // px/sec (horizontal drift)
    this.life = life;        // seconds left
    this.maxLife = life;
    this.rot = rot;
    this.rotSpeed = rotSpeed;
    this.color = color || '#f48fb1';
  }

  update(dt){
    this.x += this.vx * dt;
    this.y -= this.vy * dt; // move up
    this.rot += this.rotSpeed * dt;
    this.life -= dt;
  }

  draw(ctx){
    const t = Math.max(0, this.life / this.maxLife); // 1 -> 0
    ctx.save();
    ctx.globalAlpha = t;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);
    // scale normalized heart (base 24 units) to required size
    const scale = this.size / 24;
    ctx.scale(scale, scale);
    ctx.fillStyle = this.color;
    drawHeartPath(ctx);
    ctx.fill();
    ctx.restore();
  }
}

// spawn heart at a random angle around the model base (radius ~ modelRadius * 1.3)
function spawnHeartAroundModel(){
  const cw = canvas.clientWidth;
  const ch = canvas.clientHeight;
  const centerX = cw / 2;
  // spawn around a vertical position near model base (a bit above bottom of viewer area)
  const baseY = Math.round(ch * 0.68);

  const baseRadius = getModelRadiusPx() * 1.3;
  const angle = Math.random() * Math.PI * 2;
  // distribute near ring: between 55% - 95% of radius to avoid exact center
  const r = baseRadius * (0.55 + Math.random() * 0.4);
  const x = centerX + Math.cos(angle) * r;
  const y = baseY + Math.sin(angle) * (baseRadius * 0.12); // small vertical offset

  const size = 6 + Math.random() * 14;   // px
  const vy = 18 + Math.random() * 38;    // px/sec upward (tune to be slow)
  const vx = (Math.random() - 0.5) * 30; // horizontal drift
  const life = 1.2 + Math.random() * 0.9; // seconds (1.2 - 2.1s)
  const rot = (Math.random() - 0.5) * Math.PI;
  const rotSpeed = (Math.random() - 0.5) * 1.8;
  const color = Math.random() > 0.85 ? '#ffd1dc' : '#f48fb1'; // small color variety

  hearts.push(new Heart(x, y, size, vy, vx, life, rot, rotSpeed, color));
}

let lastFrame = performance.now();
function heartLoop(now){
  const dt = Math.min(0.05, (now - lastFrame) / 1000);
  lastFrame = now;

  // keep canvas size in sync on resize/rotation
  resizeCanvas();

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // spawn rate: probability per frame (tune as needed). Lower on mobile if needed.
  if(heartsOn){
    const spawnProbPerFrame = 0.6; // ~0.6 chance per frame at 60fps -> ~36 hearts/sec (but many expire)
    if(Math.random() < spawnProbPerFrame){
      spawnHeartAroundModel();
    }
  }

  for(let i = hearts.length - 1; i >= 0; i--){
    const h = hearts[i];
    h.update(dt);
    h.draw(ctx);
    if(h.life <= 0 || h.y < -50) hearts.splice(i, 1);
  }

  requestAnimationFrame(heartLoop);
}
requestAnimationFrame(heartLoop);

// Public toggle (existing UI button)
if(typeof toggleParticlesBtn !== 'undefined'){
  toggleParticlesBtn.addEventListener('click', ()=>{
    heartsOn = !heartsOn;
    toggleParticlesBtn.textContent = heartsOn ? 'Toggle Particles' : 'Particles Off';
  });
}

// Hide hearts when AR is active (preserve AR view)
mv.addEventListener('ar-status', (evt) => {
  const status = evt.detail?.status || '';
  if(status.includes('session-started') || status.includes('presenting') || status.includes('in-ar')){
    heartsOn = false;
  }else{
    heartsOn = true;
  }
});

// Allow manual override of model radius (px) from console
window.setModelRadiusPx = function(px){
  viewerWrap.setAttribute('data-model-radius', px);
  console.log('Model radius override set to', px, 'px');
};
